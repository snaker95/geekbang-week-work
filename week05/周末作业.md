## 限流、熔断、降级的常用方式

------

### 限流：

也称为过载保护，流量过载的时候, 主动拒绝的一种机制, 在一定程度上, 保护后端服务最大程度稳定提供服务能力, 避免 oom 掉; (**oom**: out of memory) 

* 常见方式或者算法

  * **单机限流**

    * **令牌桶算法**, 例如 google 提供的 `x/time/rate`

      * 优点:

      1. ​	稳定可靠，实现简单，性能高
         1. 支持突发流量应对
      2. 缺点:
         1. 流量不均匀会导致误限制
         2. **阈值**设置较为困难，需要提前压测
         3. 人力成本高，增减服务实例需人工介入重新调整

    * **漏桶算法**, 例如: uber 的 `ratelimit`

      * 优点:
        * 稳定可靠，实现简单，性能高
      * 缺点:
        1. 流量不均匀会导致误限制
        2. 阈值设置较为困难，需要提前压测
        3. 不支持突发流量

    * **自适应限流**, 例如: `BBR 限流`

      * 优点:
        1. 利用**利特尔法则**(L = λ * W), 根据服务状态进行动态限流
        2. 阈值设置简单，无需提前进行压测, 使用 pass * rt (临近负载的吞吐) < inflight
        3. 服务扩容无需手动调整阈值
      * 缺点:
        1. 需要主动采集相关指标数据（cpu等）, 需要单独开发

  * **全局限流** 

    *  **分布式限流**
       * 优点:
         1. 流量不均不会误触限流，有全局数据，利用**max-min-fairness 最大最小公平分享**可以合理进行分配
         2. 服务扩容无需手动调整阈值

### 熔断:

是指客户端(client) 主动截流，其实是限流实现的一种方式，只是实施方不同

使用**Google SRE 过载保护算法** : max(0, (requests - k * accepts)/(requests+1)), 控制熔断器的开关

* 可见: hystrix-go

### 降级:

降低质量的回复, 也就是提供有损服务

* 常用方式
  * 手动降级
  * 自动降级
* 降级策略
  * 页面降级、延迟服务、读写降级、缓存降级
  * 抛异常、返回约定协议、mock 数据、Fallback处理
* 最佳实践
  * UI 模块化, 非核心模块降级
    * BFF 层聚合 API, 模块降级
  * 使用上一次缓存
  * 使用默认值、热门推荐数据
  * 流量拦截+定期数据缓存, 其实是过期副本的策略



## 重试的注意事项

-------

* 限制重试次数: 建议不大于 3 次
* 基于重试分布的策略(重试比: 10%): 重试流量不大于正常流程的10%
* 重试周期: 采用随机化、指数型重试
* 增加重试次数传递, server 端通过重试的次数确定优先级
* 仅在失败的层做重试, 重试后仍失败, 需要全局约定, 避免级联重试



## 负载均衡的常用方式

----

1. 轮询法

   1. 最闲轮询法 JSQ
   2. 随机轮询法
   3. 加权轮询

2. 随机法

   1. 加权随机法

3. 哈希法

   1. 源地址哈希法

4. 最小连接数法

5. 动态均衡

   1. P2P法, 利用服务器 CPU、内存、load 等作为指标进行分发

   